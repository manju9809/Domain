/ SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract DNAChain {
    // State variables
    address public owner;
    
    // Struct to store DNA record
    struct DNARecord {
        bytes32 dnaHash;
        string metadata;
        uint256 timestamp;
        address individual;
        bool exists;
    }
    
    // Struct to store access permissions
    struct AccessPermission {
        address researcher;
        uint256 expiryTime;
        string purpose;
        bool isActive;
    }
    
    // Mappings
    mapping(address => DNARecord) public dnaRecords;
    mapping(address => mapping(address => AccessPermission)) public accessPermissions;
    mapping(address => bool) public authorizedUsers;
    
    // Events
    event DNAHashStored(address indexed individual, bytes32 dnaHash, uint256 timestamp);
    event AccessGranted(address indexed individual, address indexed researcher, uint256 duration, string purpose);
    event AccessRevoked(address indexed individual, address indexed researcher);
    event AuthorizedUserAdded(address indexed user);
    event AuthorizedUserRemoved(address indexed user);
    
    // Modifiers
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }
    
    modifier onlyAuthorized() {
        require(authorizedUsers[msg.sender] || msg.sender == owner, "Not authorized to perform this action");
        _;
    }
    
    modifier validAddress(address _addr) {
        require(_addr != address(0), "Invalid address");
        _;
    }
    
    // Constructor
    constructor() {
        owner = msg.sender;
        authorizedUsers[owner] = true;
    }
    
    // Core Function 1: Store DNA Hash
    function storeDNAHash(
        bytes32 _dnaHash,
        string memory _metadata,
        uint256 _timestamp
    ) external onlyAuthorized {
        require(_dnaHash != bytes32(0), "DNA hash cannot be empty");
        require(_timestamp <= block.timestamp, "Timestamp cannot be in the future");
        require(!dnaRecords[msg.sender].exists, "DNA record already exists for this address");
        
        dnaRecords[msg.sender] = DNARecord({
            dnaHash: _dnaHash,
            metadata: _metadata,
            timestamp: _timestamp,
            individual: msg.sender,
            exists: true
        });
        
        emit DNAHashStored(msg.sender, _dnaHash, _timestamp);
    }
    
    // Core Function 2: Verify DNA Identity
    function verifyDNAIdentity(
        address _individual,
        bytes32 _dnaHash
    ) external view validAddress(_individual) returns (bool) {
        require(_dnaHash != bytes32(0), "DNA hash cannot be empty");
        
        DNARecord memory record = dnaRecords[_individual];
        return (record.exists && record.dnaHash == _dnaHash);
    }
    
    // Core Function 3: Grant Access Permission
    function grantAccess(
        address _researcher,
        uint256 _duration,
        string memory _purpose
    ) external validAddress(_researcher) {
        require(_duration > 0, "Duration must be greater than 0");
        require(bytes(_purpose).length > 0, "Purpose cannot be empty");
        require(dnaRecords[msg.sender].exists, "No DNA record found for sender");
        
        uint256 expiryTime = block.timestamp + _duration;
        
        accessPermissions[msg.sender][_researcher] = AccessPermission({
            researcher: _researcher,
            expiryTime: expiryTime,
            purpose: _purpose,
            isActive: true
        });
        
        emit AccessGranted(msg.sender, _researcher, _duration, _purpose);
    }
    
    // Additional utility functions
    
    // Check if researcher has valid access to individual's data
    function hasValidAccess(address _individual, address _researcher) 
        external 
        view 
        validAddress(_individual) 
        validAddress(_researcher) 
        returns (bool) 
    {
        AccessPermission memory permission = accessPermissions[_individual][_researcher];
        return (permission.isActive && permission.expiryTime > block.timestamp);
    }
    
    // Revoke access permission
    function revokeAccess(address _researcher) external validAddress(_researcher) {
        require(accessPermissions[msg.sender][_researcher].isActive, "No active permission found");
        
        accessPermissions[msg.sender][_researcher].isActive = false;
        emit AccessRevoked(msg.sender, _researcher);
    }
    
    // Get DNA record details (only for authorized users)
    function getDNARecord(address _individual) 
        external 
        view 
        onlyAuthorized 
        validAddress(_individual) 
        returns (
            bytes32 dnaHash,
            string memory metadata,
            uint256 timestamp,
            bool exists
        ) 
    {
        DNARecord memory record = dnaRecords[_individual];
        return (record.dnaHash, record.metadata, record.timestamp, record.exists);
    }
    
    // Get access permission details
    function getAccessPermission(address _individual, address _researcher)
        external
        view
        validAddress(_individual)
        validAddress(_researcher)
        returns (
            uint256 expiryTime,
            string memory purpose,
            bool isActive
        )
    {
        require(
            msg.sender == _individual || 
            msg.sender == _researcher || 
            authorizedUsers[msg.sender],
            "Not authorized to view this permission"
        );
        
        AccessPermission memory permission = accessPermissions[_individual][_researcher];
        return (permission.expiryTime, permission.purpose, permission.isActive);
    }
    
    // Owner functions
    
    // Add authorized user
    function addAuthorizedUser(address _user) external onlyOwner validAddress(_user) {
        require(!authorizedUsers[_user], "User is already authorized");
        authorizedUsers[_user] = true;
        emit AuthorizedUserAdded(_user);
    }
    
    // Remove authorized user
    function removeAuthorizedUser(address _user) external onlyOwner validAddress(_user) {
        require(_user != owner, "Cannot remove owner authorization");
        require(authorizedUsers[_user], "User is not authorized");
        authorizedUsers[_user] = false;
        emit AuthorizedUserRemoved(_user);
    }
    
    // Transfer ownership
    function transferOwnership(address _newOwner) external onlyOwner validAddress(_newOwner) {
        require(_newOwner != owner, "New owner must be different from current owner");
        
        // Remove old owner from authorized users and add new owner
        authorizedUsers[owner] = false;
        authorizedUsers[_newOwner] = true;
        owner = _newOwner;
    }
    
    // Emergency functions
    
    // Update DNA record (only by record owner)
    function updateDNARecord(
        bytes32 _newDnaHash,
        string memory _newMetadata
    ) external {
        require(dnaRecords[msg.sender].exists, "No DNA record found");
        require(_newDnaHash != bytes32(0), "DNA hash cannot be empty");
        
        dnaRecords[msg.sender].dnaHash = _newDnaHash;
        dnaRecords[msg.sender].metadata = _newMetadata;
        dnaRecords[msg.sender].timestamp = block.timestamp;
        
        emit DNAHashStored(msg.sender, _newDnaHash, block.timestamp);
    }
    
    // Delete DNA record (only by record owner)
    function deleteDNARecord() external {
        require(dnaRecords[msg.sender].exists, "No DNA record found");
        
        delete dnaRecords[msg.sender];
    }
}
